-- PROJET3 STL 12-13 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

--table des classes
inh tds :TDS for   CORPS, DEFS, DEF,
                 BLOC, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
           -- je crois qu'il faut enlever tout les trucs avec un X Ã  la fin 
  
 
 --table ou on met toutes les classes
 inh tdsProg: TDS for PROGRAMME, CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                 BLOC,SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
 --table des attributs          
--inh tda : TDS for DEFS, DEF ;
 --table des mÃ©thodes
--inh tdm : TDS for DEFS, DEF, MCORPS, BLOC, INSTS, INST, SIX, E, ER, ES, F, 
  --                 AFFX, ERX, ESX, TX, ARGSX,ARGS;
 --table des constructeurs
--inh tdc : TDS for DEFS, DEF, MCORPS, BLOC, INSTS, INST, SIX, E, ER, ES, F, 
    --                AFFX, ERX, ESX, TX, ARGSX,ARGS;

--table de parametres
syn param: String for PARF;
inh tdsParamh :TDS for BLOC,INSTS,INST, SIX,E, ER, ES, F, AFFX,FACTEUR,TERME, ERX, ESX, TX, ARGSX,ARGS,FX;
syn tdsParam: TDS for PARFS,PARFSX;

syn superclass : INFO for SUPER;
syn type : DTYPE for TYPE, PARF, FACTEUR, E, ER,ES,AFFX,TERME,F,FX, ERX, ESX, TX,
OPREL,OPADD,OPMUL,OPUN ;
--type de retour de la mÃ©thode
inh typeR : DTYPE for BLOC, INSTS,INST,SIX;
--signature d une fonction
syn signature : LTYPES for PARFS, PARFSX;
 
syn listArg : LTYPES for ARGSX,ARGS;

--les infos sur de la classe a donner au corps de la classe
inh infoclass : INFOCLASS for FX,CORPS, DEFS,DEF,INSTS,INST,BLOC,TYPE,
                 PARFS,PARFSX, PARF, 
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F, ARGS, ARGSX;
                               
--les infos sur de la methode a donner au corps de la classe
inh infoMethod : INFOMETHOD for INSTS,INST,BLOC,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;               
inh nom :String for FX;
inh htype: DTYPE for FX;


--code
--syn code : STRING for  BLOC,INSTS, INST, E,TERME, FACTEUR, FX, TERMES;
--inh hcode : STRING for INSTS, INST;

--syn adr : INTEGER for INSTS, INST;
--inh hadr: INTEGER for INSTS, INST; 
--TAM
--inh tam : TAM for BLOC, INSTS,  INST, TERME, FACTEUR, FX, TERMES;

-- les terminaux 
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ","; 
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar extend is  "extends";
sugar retour is  "return";
sugar this is  "this";
sugar super is  "super";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init #tds CLASSES #gen;
global
   machine : AbstractMachine;
   t: TDS;

#init {
local
do
   machine := PROGRAMME^source.getMachine();
end
}

#tds{
do
-- creer la table pour les classes du programme
 t:= new TDS();
-- transmettre la table Ã  CLASSES
CLASSES^tdsProg:=t;
end
}
#gen {
local
do
  call machine.writeCode(PROGRAMME^source.getFileName(), "; GC"); 
end
}

CLASSES ->;
CLASSES -> DEFCLASSE CLASSES;
-- definition d'une classe
DEFCLASSE -> classe ident SUPER #tds CORPS #gen;
global
  t: TDS;
#tds{
local
    i : INFOCLASS ;
do
   
   t :=  new TDS(DEFCLASSE^tdsProg);
   CORPS^tds := t;  -- on devrait pas rajouter la tds des classes meres ?
--   CORPS^classname:=ident^txt;   
    i := DEFCLASSE^tdsProg.chercherGlobalement(ident^txt);
    if i /= nil then
       error(class_existe_deja, ident^txt);
    else    
      -- creer une classe
     i := new INFOCLASS(ident^txt, SUPER^superclass);   --il faut donner la liste des attributs et des methodes et sa classe mÃ¨re
                                      -- qui seront probablemnt des attribut synthÃ©tisÃ©
     call DEFCLASSE^tdsProg.inserer(ident^txt,  i);
     call i.setParent(SUPER^superclass);
     CORPS^infoclass:=i;

    end
end
}
#gen {

do


end
}

SUPER -> #classmere;
#classmere{
do
SUPER^superclass:=nil;
end
}
SUPER -> extend ident #gen;

#gen {
local
    i : INFOCLASS ;
do
    i := SUPER^tdsProg.chercherGlobalement(ident^txt);
    if i = nil then
       error(class_non_existe, ident^txt);
    else    
      -- donner le nom de la classe mÃ¨re Ã  la classe fille
     SUPER^superclass:=i;               
    end
end
}
CORPS -> aco #tables DEFS acf;
#tables{
local
 --tabA:TDS;
 --tabM:TDS;
-- tabC:TDS;
-- tab:TDS;
-- i:INFOCLASS ;
 
do
--tab:=CORPS^tds;
--i:=tab.getParent();
--tabA:=new TDS(i);--il faut donner la classe mere de la classe tds
--tabM:=new TDS(CORPS^tds);
--tabC:=new TDS(CORPS^tds);

end
}


-- les attributs
DEFS ->;

DEFS ->  DEF DEFS;
-- attribut
DEF ->  TYPE ident pv #tds;

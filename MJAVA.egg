-- PROJET3 STL 12-13 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

inh tds :TDS for PROGRAMME, CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                 BLOC,SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
           -- je crois qu'il faut enlever tout les trucs avec un X à la fin 
           
syn superclass : INFO for SUPER;
syn type : Type for TYPE;

syn code : STRING for INSTS, INST;
inh hcode : STRING for INSTS, INST;

syn adr : INTEGER for INSTS, INST;
inh hadr: INTEGER for INSTS, INST;
inh liste : LTYPES for PARFS, PARF, PARFSX; 

-- les terminaux 
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ","; 
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar extend is  "extends";
sugar retour is  "return";
sugar this is  "this";
sugar super is  "super";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init #tds CLASSES #gen;
global
   machine : AbstractMachine;
   t: TDS;

#init {
local
do
   machine := PROGRAMME^source.getMachine();
end
}

#tds{
do
-- creer la table pour les classes du programme
 t:= new TDS(nil);
-- transmettre la table à CLASSES
CLASSES^tds:=t;
end
}
#gen {
local
do
  call machine.writeCode(PROGRAMME^source.getFileName(), "; GC"); 
end
}

CLASSES ->;
CLASSES -> DEFCLASSE CLASSES;
-- definition d'une classe
DEFCLASSE -> classe ident SUPER #tds CORPS #gen;
global
  t: TDS;
#tds{
do
   t :=  new TDS(DEFCLASSE^tds);
   CORPS^tds := t;  -- on devrait pas rajouter la tds des classes meres ?
end
}
#gen {
local
    i : INFOCLASS ;
do

    i := DEFCLASSE^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(class_existe_deja, ident^txt);
    else    
      -- creer une classe
     i := new INFOCLASS(ident^txt, SUPER^superclass);   --il faut donner la liste des attributs et des méthodes et sa classe mère
                                      -- qui seront probablemnt des attribut synthétisé
     call DEFCLASSE^tds.inserer(ident^txt,  i);
    end
end
}

SUPER -> #classmere;
#classmere{
do
SUPER^superclass:=nil;
end
}
SUPER -> extend ident #gen;

#gen {
local
    i : INFOCLASS ;
do
    i := SUPER^tds.chercherGlobalement(ident^txt);
    if i = nil then
       error(class_non_existe, ident^txt);
    else    
      -- donner le nom de la classe mère à la classe fille
     SUPER^superclass:=i;               
    end
end
}
CORPS -> aco DEFS acf;
#tds {
do
DEFS^tds := CORPS^tds ;
end
}
-- les attributs
DEFS ->;
DEFS ->  DEF DEFS;
-- attribut
DEF ->  TYPE ident pv #tds;
#tds {
local 
i : INFO;
do
  i := DEF^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(attr_existe_deja, ident^txt);
    else    
      -- creer un attribut
     i := new INFOTYPE(TYPE^type);   --ou ptetr new INFOATTR(ident^txt, TYPE^type)
                                     -- a voir selon les classes a ecrire
     call DEF^tds.inserer(ident^txt,  i);
    end
end
}

-- methode (fonction) 
DEF ->  TYPE ident paro PARFS parf  BLOC #tds;
#tds {
local 
i : INFO;
do
  i := DEF^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(methode_existe_deja, ident^txt);
    else    
      -- creer un attribut
     i := new INFOMETHODE(TYPE^type,PARFS^liste);  
     call DEF^tds.inserer(ident^txt,i);
    end
end
}

-- methode (procedure)
DEF ->  void ident paro PARFS parf BLOC #tds;
#tds {
local 
i : INFO;
do
  i := DEF^tds.chercherGlobalement(ident^txt);
    if i /= nil then
      -- faire match ici , si trouve infoAttr pas de probleme 
      -- si trouve infoMethode on teste si la mm liste de param -> erreur sinn pas de probleme
      error(methode_existe_deja, ident^txt);
    else    
      
     i := new INFOMETHODE(new VOIDTYPE() ,PARFS^liste);  
     call DEF^tds.inserer(ident^txt,i);
    end
end
}

-- constructeur
DEF -> ident  paro PARFS parf BLOC;

-- les types

TYPE-> int #type;
#type{
do 
TYPE^type := new IntDTYPE();
}

TYPE-> bool #type;
#type{
do 
TYPE^type := new BoolDTYPE();
}

TYPE-> ident #type;
#type{
do 
local
   i : INFO ;
    it : INFOTYPE;
 do
    -- rechercher l'ident   
    i := TYPE^tds.chercherGlobalement(ident^txt);
    if i = nil then
      error(type_non_existant, ident^txt);
    else
       match i
       with INFOTYPE then
         it := i ;
         TYPE^type :=  it.getType();
       else
          error(not_a_type, ident^txt);
       end
    end
  end
}


}
-- parametres de methodes
PARFS -> ;
PARFS -> PARF PARFSX #params;
#params{

do
PARFS^liste := PARFSX^liste.inserer(PARF^type);

end
}
PARFSX -> #params;
#params{
do
PARFSX^liste := new LTYPES();
end
}

PARFSX -> virg PARF PARFSX #params;
#params{

do
PARFSX^liste := PARFSX1^liste.inserer(PARF^type);

end
}
PARF -> TYPE ident #param;
#param{
do
PARF^type := TYPE^type;
end
}

-- corps de methode et bloc d'instructions
BLOC -> aco #tds INSTS acf ;
global
 t:TDS;
#tds{
do
t:= BLOC^tds;
INSTS^tds:= new TDS(t);
end
}
-- instructions
INSTS -> #gen;
#gen{
do 
  INSTS^adr := INSTS^hadr;
  INSTS^code := "";
}

INSTS -> INST #adr INSTS #gen;

#adr{
do 
 INSTS^hadr := INST^code;
 end
 }

#gen{
do 

INSTS^adr := INSTS1^adr;
INSTS^code := INST^code + INSTS1^code;
end
}


-- declaration de variable locale avec ou sans init
INST-> TYPE ident pv ;  --rien a faire ?!

INST-> TYPE ident affect E pv #gen;

#gen{  ici !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
local

 i : INFO ;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(B_00, ident^txt);
    else    
      -- creer un type
     i := new INFOTYPE(TYPE^type);
     call INST^tds.inserer(ident^txt,  i);
     INST^adr := INST^hadr ;
     INST^code := "";
    end
end
}

-- instruction expression
INST -> E pv ;
-- bloc d'instructions
INST -> BLOC ;
-- conditionnelle
INST -> si paro E parf BLOC SIX ;
SIX -> sinon BLOC ;
SIX ->;
-- return
INST -> retour E pv ;
-- les expressions
E ->  ER AFFX ;
-- affectation
AFFX ->  affect ER  ;
AFFX -> ;
-- relation
ER ->   ES ERX ;
ES ->  TERME ESX ;
ERX ->  OPREL ES ;
ERX -> ;
OPREL -> inf ;
OPREL -> infeg ;
OPREL -> sup ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
-- addition, ...
ESX ->   OPADD TERME ESX ;
ESX ->;
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
TERME ->  FACTEUR TX ;
-- multiplication, ...
TX ->   OPMUL FACTEUR TX ;
TX -> ;
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- unaire
FACTEUR ->  OPUN FACTEUR ;
OPUN -> plus;
OPUN -> moins;
OPUN -> non;
-- expressions de base
FACTEUR -> entier;
-- booleens
FACTEUR -> vrai;
FACTEUR -> faux;
-- null
FACTEUR -> null;
FACTEUR -> F;
-- expression parenthésée
F -> paro E parf ;
-- new
F -> nouveau TYPE paro ARGS parf  FX;
-- objet courant
F -> this  FX;
-- objet parent
F -> super  FX;
-- acces variable, parametre, ou attribut de this
F -> ident FX;
FX -> ;
FX -> pt ident FX;
-- appel methode sur objet
FX -> paro ARGS parf FX;
-- liste d'arguments d'appel de methode
ARGS ->  E ARGSX  ;
ARGS -> ;
ARGSX ->   virg E ARGSX  ;
ARGSX -> ;

end

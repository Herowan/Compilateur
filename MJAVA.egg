-- PROJET3 STL 12-13 - micro java : grammaire 
option auto= true;
option version = 0.0.1 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

--table des classes
inh tds :TDS for   
                 INSTS,INST,--BLOC, PARFS,PARFSX, PARF, 
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
           -- je crois qu'il faut enlever tout les trucs avec un X Ã  la fin 
  
 
 --table ou on met toutes les classes
 inh tdsProg: TDS for PROGRAMME, CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                 BLOC,SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
 --table des attributs          
--inh tda : TDS for DEFS, DEF ;
 --table des methodes
--inh tdm : TDS for DEFS, DEF, MCORPS, BLOC, INSTS, INST, SIX, E, ER, ES, F, 
  --                 AFFX, ERX, ESX, TX, ARGSX,ARGS;
 --table des constructeurs
--inh tdc : TDS for DEFS, DEF, MCORPS, BLOC, INSTS, INST, SIX, E, ER, ES, F, 
    --                AFFX, ERX, ESX, TX, ARGSX,ARGS;

--table de parametres
syn param: String for PARF;
inh tdsParamh :TDS for BLOC,INSTS,INST, SIX,E, ER, ES, F, AFFX,FACTEUR,TERME, ERX, ESX, TX, ARGSX,ARGS,FX;
syn tdsParam: TDS for PARFS,PARFSX;

syn superclass : INFOCLASS for SUPER;
syn type : DTYPE for TYPE, PARF, FACTEUR, E, ER,ES,AFFX,TERME,F,FX, ERX, ESX, TX,
OPREL,OPADD,OPMUL,OPUN ;
--type de retour de la mÃ©thode
inh typeR : DTYPE for BLOC, INSTS,INST,SIX;
--signature d une fonction
syn signature : LTYPES for PARFS, PARFSX;
 
syn listArg : LTYPES for ARGSX,ARGS;

--les infos sur de la classe a donner au corps de la classe
inh infoclass : INFOCLASS for CORPS, DEFS,DEF,INSTS,INST,BLOC,TYPE,
                 PARFS,PARFSX, PARF, 
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
                               
--les infos sur de la methode a donner au corps de la classe
inh infoMethod : INFOMETHOD for INSTS,INST,BLOC,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;               
inh nom :String for FX;
inh htype: DTYPE for FX;


--code
syn code : STRING for  CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                 BLOC, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX, OPADD,OPMUL,OPREL,OPUN;
inh hcode : STRING for FX;-- CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                -- BLOC,SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                -- SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 --F,FX, ARGS, ARGSX;

--TAM
--inh tam : TAM for BLOC, INSTS,  INST, TERME, FACTEUR, FX, TERMES;
inh machine : AbstractMachine for PROGRAMME, CLASSES, DEFCLASSE, CORPS, DEFS, DEF,BLOC,
                 SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX, OPADD,OPMUL,OPREL,OPUN;

-- adresses
syn dep : INTEGER for BLOC, INST, INSTS;-- DEF;--, DEFS, ,DEFCLASSE,E;
inh hdep : INTEGER for BLOC,INST,INSTS,PARF, PARFS,PARFSX, DEFS, DEF, SIX ;
--inh hdep: INTEGER for DEFS, DEF, CORPS,CLASSES, DEFCLASSE, BLOC, INST, INSTS, SIX;

-- les terminaux 
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ","; 
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar extend is  "extends";
sugar retour is  "return";
sugar this is  "this";
sugar super is  "super";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init #tds CLASSES #gen;
global
   machine : AbstractMachine;
   t: TDS;

#init {
local
do
   machine := PROGRAMME^source.getMachine();
--   CLASSES^hdep:=0;
--   CLASSES^hcode:="";   

end
}

#tds{
do
-- creer la table pour les classes du programme
 t:= new TDS();
-- transmettre la table a  CLASSES
CLASSES^tdsProg:=t;
end
}
#gen {
local
  cp : STRING ; -- code de la procedure
do
 call machine.writeCode(PROGRAMME^source.getFileName(), "; GC"); 
   -- code de la procedure : generer le prologue et l'epilogue 
   -- etiquette + taille des parametres + taille retour + code des instructions
 --  cp := tam.genFonction( ,0 , 0, BLOC^code);              --MOUNA
   -- generer le code complet
      -- ajouter un appel a la fonction en debut de programme
  -- call tam.genAsm(ident^txt, cp);
 
end
}

CLASSES -> #gen;
#gen{
do
CLASSES^code:="";--CLASSES^hcode;

end
}
CLASSES -> DEFCLASSE #dep  CLASSES #gen ;
#dep{
do
--CLASSES1^hdep := DEFCLASSE^dep ;
end
}
#gen{
do
CLASSES^code := DEFCLASSE^code + CLASSES1^code ;
end
}
-- definition d'une classe
DEFCLASSE -> classe ident SUPER #tds #gen1 CORPS #gen;
global
--  t: TDS;
#tds{
local
    ic : INFOCLASS ;
    i:INFO;
do
   
 --  t :=  new TDS(DEFCLASSE^tdsProg);
 --  CORPS^tds := t;  -- on devrait pas rajouter la tds des classes meres ?
--   CORPS^classname:=ident^txt;   
    i := DEFCLASSE^tdsProg.chercherGlobalement(ident^txt);
    if i /= nil then
       error(class_existe_deja, ident^txt);
    else    
      -- creer une classe
      if(SUPER^superclass=nil) then
           ic := new INFOCLASS(ident^txt);
      else
           ic := new INFOCLASS(ident^txt, SUPER^superclass);   --il faut donner la liste des attributs et des methodes et sa classe mere
      end                               -- qui seront probablemnt des attribut synthetise
     call DEFCLASSE^tdsProg.inserer(ident^txt,  ic);
--     call ic.setParent(SUPER^superclass);
     CORPS^infoclass:=ic;

    end
end
}
#gen {   --generation de code !
do
--DEFCLASSE^dep := DEFCLASSE^hdep + 1;
DEFCLASSE^code := CORPS^code;
end
}

#gen1{
do
--CORPS^hdep := DEFCLASSE^hdep;
end 
}


SUPER -> #classmere;
#classmere{
do
SUPER^superclass:=nil;
end
}
SUPER -> extend ident #gen;

#gen {
local
    i : INFO ;
    ic: INFOCLASS;
do
    i := SUPER^tdsProg.chercherGlobalement(ident^txt);
    if i = nil then
       error(class_non_existe, ident^txt);
    else   
      match i 
      with INFOCLASS then
        ic:=i; 
      -- donner le nom de la classe mere a  la classe fille
        SUPER^superclass:=ic;  
      else
        error(pas_une_classe,ident^txt );
      end             
    end
end
}
CORPS -> aco #hdep DEFS acf #gen;
#hdep{
do
DEFS^hdep:=3;
end
}
#gen{
do
CORPS^code:=DEFS^code;
end
}

-- les attributs
DEFS -> #gen;
#gen{
do
DEFS^code:="";
end
}

DEFS ->  DEF #dep DEFS #gen;
#dep{
do
--    DEFS1^hdep := DEFS^hdep + DEF^dep ;
end
}
#gen{
do
DEFS^code:= DEF^code + DEFS1^code;
end
}


-- attribut
DEF ->  TYPE ident pv #tds;
#tds {
local 
i : INFO;  
ia: INFOATTRIBUTE;
t:TDS;
do
DEF^code:="";                           -- pas de code pour les attributs
t:=DEF^infoclass.getAttributes();
i := t.chercherLocalement(ident^txt);   -- possiblite de redefinition dun attribut dans la classe
                                        -- fille                                          
    if i /= nil then
       error(attribut_existe_deja, ident^txt);
    else    
      -- creer un attribut
     ia := new INFOATTRIBUTE(ident^txt,TYPE^type);--,dep,reg);           --   modifier pour TAM
 --    call DEF^tds.inserer(ident^txt,  ia);
     --mise Ã  jour de la tds des attributs
     call DEF^infoclass.addAttribute(ident^txt,ia);

    end
end
}

-- methode (fonction) 
DEF ->  TYPE ident paro PARFS parf #tds  BLOC #gen  ;
#tds {
local 
i : INFO;
im: INFOMETHOD;
t:TDM;
s: String;
do
 BLOC^hdep:=3;
 t:=DEF^infoclass.getMethods();
 i := t.chercherLocalement(ident^txt,PARFS^signature);
 if i /= nil then
    error(methode_existe_deja, ident^txt);
 else    
     -- creer une methode           
    im := new INFOMETHOD(ident^txt,TYPE^type,PARFS^signature,true);  -- a modifier  TAM
    --ajouter la liste des parametres(une TDS) a l infoMethod 
    call im.setListParam(PARFS^tdsParam);
  --  call DEF^tds.inserer(ident^txt,im);
     --mise a jour de la tds des methodes
    s:=im.getName();
    call DEF^infoclass.addMethod(s,im);
     
    --on donne l infoMethod au bloc 
    BLOC^infoMethod:=im;
    BLOC^tdsParamh:=PARFS^tdsParam;
    BLOC^typeR:=TYPE^type;
    end
end
}
#gen{
local
ic:INFOCLASS;
tailleParam:Integer;
do
 ic:= DEF^infoclass;
 tailleParam:=PARFS^signature.getTaille();
 DEF^code:= DEF^machine.genFonction(ic.getName(),ident^txt,tailleParam, TYPE^type.getTaille() , BLOC^code);   
 end
 }
-- methode (procedure)
DEF ->  void ident paro PARFS  parf  #tds BLOC #gen ;

#tds {
local 
i : INFO;
im:INFOMETHOD;
t:TDM;
s:String;
do
 BLOC^hdep:=3;
 t:=DEF^infoclass.getMethods();
 i := t.chercherLocalement(ident^txt,PARFS^signature);
 if i /= nil then
      error(methode_existe_deja, ident^txt);
    else    
     im := new INFOMETHOD(ident^txt,new VoidDTYPE() ,PARFS^signature,false);
     --ajouter la liste des parametres(une TDS) a l infoMethod 
    call im.setListParam(PARFS^tdsParam);  
--    call DEF^tds.inserer(ident^txt,im);
    s:=im.getName();
    call DEF^infoclass.addMethod(s,im);
     
    --on donne l infoMethod au bloc
    BLOC^infoMethod:=im;         --on peut enlever les deux lignes suivantes
    BLOC^tdsParamh:=PARFS^tdsParam;
    BLOC^typeR:=im.getType();
    end
end
}

#gen{
local
ic:INFOCLASS;
tailleParam:Integer;
do
 ic:= DEF^infoclass;
 tailleParam:=PARFS^signature.getTaille();
 DEF^code:= DEF^machine.genFonction(ic.getName(),ident^txt,tailleParam, 0 , BLOC^code);   
 end
 }

-- constructeur
DEF -> ident  paro PARFS parf #tds BLOC #gen;
global
im:INFOMETHOD;
#tds{
local
i:INFO;
nomClass:String;
t:TDM;
a:String;
ti:DTYPE;
s:String;
do 
 BLOC^hdep:=3;
 nomClass:=DEF^infoclass.getName();
 if (ident^txt.equals( nomClass)) then
  t:= DEF^infoclass.getConstructors();

  i:= t.chercherLocalement(ident^txt,PARFS^signature);
  if (i=nil) then 
    i:= t.chercherGlobalement(ident^txt,PARFS^signature);
    if (i/=nil) then
        --traitement de super
    end
    im := new INFOMETHOD(ident^txt,new ClassDTYPE(ident^txt) ,PARFS^signature,false);
        --ajouter la liste des parametres(une TDS) a l infoMethod 
    call im.setListParam(PARFS^tdsParam);               
--    call DEF^tds.inserer(ident^txt,im);
    s:=im.getName();
    call DEF^infoclass.addConstructor(s,im);
    
    --on donne l infoMethod au bloc
    BLOC^infoMethod:=im; 
    BLOC^tdsParamh:=PARFS^tdsParam;
    BLOC^typeR:=im.getType();
  else
      error(construc_existe_deja, ident^txt);  
  end                                          
 else
      error(construc_name, ident^txt);  
 end
end
 }
#gen{
local
ic:INFOCLASS;
tailleParam:Integer;
t:DTYPE;
do
t:=im.getType();
 ic:= DEF^infoclass;
 tailleParam:=PARFS^signature.getTaille();
 DEF^code:= DEF^machine.genFonction(ic.getName(),ident^txt,tailleParam, t.getTaille() , BLOC^code);   
 end
 }
-- les types

TYPE-> int #type;
#type{
do 
    TYPE^type := new IntDTYPE(); 
end
}

TYPE-> bool #type;
#type{
do 
    TYPE^type := new BoolDTYPE();  
end
}

TYPE-> ident #type;   --les classes
#type{

local
   i : INFO ;
   it : INFOCLASS;
do
    -- rechercher l'ident dans la tds du programme  
    i := TYPE^tdsProg.chercherGlobalement(ident^txt);  
    if i = nil then
      error(ident_non_existant, ident^txt);
    else
       match i
       with INFOCLASS then     
         it := i ;
         TYPE^type :=  it.getType();
       else
          error(ident_non_existant, ident^txt);
       end
    end
end
}



-- parametres de methodes
PARFS -> #paramlist;   -- methode sans parametre on cree une liste qui reste vide
#paramlist{
do 
PARFS^signature:=nil;--new LTYPES();
PARFS^tdsParam:= new TDS();
end
}

PARFS -> PARF PARFSX #params;
#params{
local
i: INFOVAR ;  --ou INFOATTRIBUTE
do
call PARFSX^signature.inserer(PARF^type); 
PARFS^signature := PARFSX^signature;
i:= new INFOVAR(PARF^type);                     --peut etre a changer en infoattribute
call PARFSX^tdsParam.inserer(PARF^param,i);
PARFS^tdsParam:=PARFSX^tdsParam;


end
}
PARFSX -> #params;
#params{
do
PARFSX^tdsParam:=new TDS();
PARFSX^signature := new LTYPES(); 
end
}

PARFSX -> virg PARF PARFSX #params;
#params{
local
i: INFOVAR ;  --ou INFOATTRIBUTE
do
call PARFSX1^signature.inserer(PARF^type);      -- methode add de arrayList attention a l'ordre
                                                -- add ajoute en fin de liste donc j ai change en add(0,elt) pour ajouter en tete
PARFSX^signature :=PARFSX1^signature;

i:= new INFOVAR(PARF^type);                     --peut etre a changer en infoattribute
call PARFSX1^tdsParam.inserer(PARF^param,i);
PARFSX^tdsParam:=PARFSX1^tdsParam;

end
}
PARF -> TYPE ident #param;
#param{
do
PARF^type := TYPE^type;   
PARF^param:= ident^txt;                             
end                                                    
}

-- corps de methode et bloc d'instructions
BLOC -> aco #tds INSTS acf #gen;

#tds{
do
INSTS^tds:= new TDS();  

                            --TAM
end
}
#gen {
local
t:TDS;
do
--   t:=INSTS^tds;
--   write "; tds:\n" + t;
--   write "; taille des locales = " + (INSTS^adr - BLOC^hadr)+ "\n";         --copiee du BLOC
    BLOC^dep:=INSTS^dep;
   BLOC^code := INSTS^code + BLOC^machine.genFree(INSTS^dep - BLOC^hdep);
end
}

-- instructions
INSTS -> #gen;
#gen{
do
-- une fonction doit avoir une instruction de retour
if (INSTS^infoMethod.isFunction()) then
    if ~(INSTS^infoMethod.getReturnInst()) then
    error(func_retour);
    end
end
    INSTS^dep := INSTS^hdep;
    INSTS^code := "";
end
}

INSTS -> INST #adr INSTS #gen;

#adr {
do
    write "@ courante = " + INST^dep + "\n";
    INSTS1^hdep := INST^dep;
end
}


#gen {
do
   INSTS^dep := INSTS1^dep;
 INSTS^code := INST^code + INSTS1^code;
end
}



-- declaration de variable locale sans init
INST-> TYPE ident pv #type #gen ;
global 
    i : INFO ;
    iv : INFOVAR ;

#type{ 
local
    t: TDS;
    t2:TDS;
do
    t:=INST^infoMethod.getListParam();
    --recherche dans la tds ou il y a les parametres de la methodes
   -- i:=INST^tdsParamh.chercherGlobalement(ident^txt);                                                     -- truc a enlever tdsParamh
    i:= t.chercherGlobalement(ident^txt);
    if i/=nil then
      error(var_egal_param,ident^txt);
    else
        i := INST^tds.chercherLocalement(ident^txt);
        if i /= nil then
          error(var_existe_deja, ident^txt);
        else
        -- creer une variable
        iv := new INFOVAR(TYPE^type);--, INST^hadr, "LB");                      -- a verifier

        --ajouter dans la tds du bloc
        call INST^tds.inserer(ident^txt,  iv);
        
        --ajouter la variable a la tds des variables de infoMethod
        t2:=INST^infoMethod.getListVar();
        call t2.inserer(ident^txt,  iv);        
        end
     end
end

}  

#gen{
do
     INST^dep := INST^hdep + TYPE^type.getTaille();
     INST^code := INST^machine.genDecl(ident^txt, iv);
 end 
     }

--declaration avec affectation
INST-> TYPE ident affect E pv #type #gen;
global 
    i : INFO ;
    iv : INFOVAR ;

#type {
local
    t: TDS;
    t2:TDS;
do
    t:=INST^infoMethod.getListParam();
    --recherche dans la tds ou il y a les parametres de la methodes
   -- i:=INST^tdsParamh.chercherGlobalement(ident^txt);                                                     -- truc a enlever tdsParamh
    i:= t.chercherGlobalement(ident^txt);
    if i/=nil then
      error(var_egal_param,ident^txt);
    else
        i := INST^tds.chercherLocalement(ident^txt);
        if i /= nil then
            error(var_existe_deja, ident^txt);
        elseif ~E^type.compareTo(TYPE^type) then
            error(type_incompatible, TYPE^type, E^type);
        else
            -- creer une variable
        iv := new INFOVAR(TYPE^type);--, INST^hadr, "LB");         --TAM
        call INST^tds.inserer(ident^txt,  iv); 
        
        --ajouter la variable a la tds des variables de infoMethod
        t2:=INST^infoMethod.getListVar();
        call t2.inserer(ident^txt,  iv);
                
        end
     end
end
}

#gen{
do
     INST^dep := INST^hdep + TYPE^type.getTaille();
     INST^code := INST^machine.genDecl(ident^txt, iv,E^code);
 end 
     }

-- instruction expression
INST -> E pv #gen;
#gen{
do
INST^dep:=0;    ------------------------------------------------------------------------------------------------------ a voir
INST^code:=E^code;
end
}                                  --generation du code ,TAM
-- bloc d'instructions
INST -> BLOC #gen ;                                  --generation du code ,TAM
#gen{
do
INST^dep:=BLOC^dep;
INST^code:=BLOC^code;
end
} 

-- conditionnelle
INST -> si paro E parf #type  BLOC SIX #gen ;
#gen {
do
    INST^dep:= INST^hdep;
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code) ;  
end
}

#type {
do
   if ~E^type.compareTo(new BoolDTYPE()) then
      error(type_incompatible, E^type); 
   end
end
}
SIX -> sinon BLOC #gen ;
#gen{
do
SIX^code := BLOC^code;
end
}

SIX ->  #gen;
#gen{
do
 SIX^code := "";                       
end
}
-- return
INST -> retour E pv #type #gen ;
#type{
local
i:INFOMETHOD;
b:boolean;
do
if (INST^infoMethod.isFunction()) then
 if  ~(INST^typeR.compareTo(E^type)) then
     error(type_incompatible,INST^typeR,E^type);
 else
     call INST^infoMethod.setReturnInst();
 end
else
    error(pas_de_retour);
                                                            -- tam
end
end 
}
#gen{
do
INST^code:= INST^machine.genRet(E^type.getTaille(),"LB");
INST^dep:=0;                                                                                            --------------------------------------------A voir
end
}


-- les expressions
E ->  ER AFFX #type;
#type{
local
    t : DTYPE ;
do
    t := AFFX^type ;
    if  t/= nil then
     if ~(t.compareTo(ER^type)) then
        error(type_incompatible, AFFX^type, ER^type);
    end
    E^type := ER^type;
    end
 E^code:= AFFX^code + E^machine.genAff(AFFX^type.getTaille(), ER^dep, ER^reg);                                                        --generation de code 
end
}

-- affectation
AFFX ->  affect ER #type ;
#type{
do
AFFX^type:=ER^type;
AFFX^code:=ER^code;
end}
AFFX -> #type ;

#type{
do
AFFX^type:=nil;                       
AFFX^code:="";                                                        --generation de code 
end}


-- relation
ER ->   ES ERX #type;
#type{
local
    t : DTYPE ;
do
    ER^code:=ES^code+ ERX^code;
    t := ERX^type ;
    if  t/= nil then
     if ~(t.compareTo(ES^type)) then
        error(type_incompatible, ERX^type, ES^type);
     else
            ER^type := new BoolDTYPE();
     end
    else
      ER^type:=ES^type;
    end  
                                                         --generation de code 
end
}
ES ->  TERME ESX #type;
#type{
local
    t : DTYPE ;
do
    ES^code:= TERME^code + ESX^code;
    t := ESX^type ;
    if  t/= nil then
     if ~(t.compareTo(TERME^type)) then
        error(type_incompatible, ESX^type, TERME^type);
     end
    end
         ES^type := TERME^type;

                                                         --generation de code 
end
}
ERX ->  OPREL ES #type;
#type{
local
    t : DTYPE ;
do
    ERX^code:=ES^code+OPREL^code;
    t := ES^type ;
    if ~(OPREL^type=nil) then           --le type de OPREL= nil dans le cas de = et /= marche 
                                        -- pour tout les types
     if ~(t.compareTo(OPREL^type)) then
        error(type_incompatible, OPREL^type, ES^type);
     end
       ERX^type := ES^type;
     end
        
                                                         --generation de code 
end
}

ERX -> #type ;
#type{
do
ERX^code:="";
ERX^type:=nil;
end}

OPREL -> inf #type ;
#type{
do
OPREL^code:=OPREL^machine.genInf();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> infeg #type ;
#type{
do
OPREL^code:=OPREL^machine.genInfeg();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> sup #type ;
#type{
do
OPREL^code:=OPREL^machine.genSup();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> supeg #type;
#type{
do
OPREL^code:=OPREL^machine.genSupeg();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> eg  #type;
#type{
do
OPREL^code:=OPREL^machine.genEg();
OPREL^type:=nil;
end
}
OPREL -> neg #type;
#type{
do
OPREL^code:=OPREL^machine.genNeg();
OPREL^type:=nil;
end
}
-- addition, ...
ESX ->   OPADD TERME ESX #type ;
#type{
local
    t1 : DTYPE ;
    t2 : DTYPE ;
do
    ESX^code:=TERME^code + ESX1^code + OPADD^code;
    t1 := TERME^type ;
    t2 := ESX1^type ; 
    if ~(t1.compareTo(OPADD^type)) then
        error(type_incompatible, OPADD^type, t1);
    else
        if (t2/=nil) then  
            if ~(t2.compareTo(t1))then 
                error(type_incompatible, t1, t2);  
            end
        end
          ESX^type := OPADD^type;
     end        
                                                     --generation de code 
end
} 

ESX -> #type;
#type{
do
ESX^code:="";
ESX^type:=nil;
end}
OPADD -> plus #type;
#type{
do
OPADD^type:=new IntDTYPE();
OPADD^code:=OPADD^machine.genAddition();
end}
OPADD -> moins #type;
#type{
do
OPADD^code:=OPADD^machine.genSoustraction();
OPADD^type:=new IntDTYPE();
end}
OPADD -> ou #type ;
#type{
do
OPADD^code:=OPADD^machine.genOu();
OPADD^type:=new BoolDTYPE();
end}

TERME ->  FACTEUR TX #type;
#type{
local
    t : DTYPE ;
do
    TERME^code:=FACTEUR^code + TX^code;
    t := TX^type ;
    if  t/= nil then
     if ~(t.compareTo(FACTEUR^type)) then
        error(type_incompatible, TX^type, FACTEUR^type);
     end
    end
     TERME^type :=FACTEUR^type;

                                                         --generation de code 
end
}
-- multiplication, ...
TX ->   OPMUL FACTEUR TX #type ;
#type{
local
    t1 : DTYPE ;
    t2 : DTYPE ;
do
    TX^code:= FACTEUR^code + TX1^code + OPMUL^code;
    t1 := FACTEUR^type ;
    t2 := TX1^type ;
    if ~(t1.compareTo(OPMUL^type)) then
        error(type_incompatible, OPMUL^type, t1);
    else
        if (t2/=nil) then  
            if ~(t2.compareTo(t1))then 
                error(type_incompatible, t1, t2);  
            end
        end
       TX^type := OPMUL^type;
     end        
                                                     --generation de code 
end
}
TX -> #type;
#type{
do
TX^code:="";
TX^type:=nil;
end
}
OPMUL -> mult #type ;
#type{
do
OPMUL^code:=OPMUL^machine.genMult();
OPMUL^type:=new IntDTYPE();
end
}
OPMUL -> div #type ;
#type{
do
OPMUL^code:=OPMUL^machine.genDiv();
OPMUL^type:=new IntDTYPE();
end
}
OPMUL -> mod #type;
#type{
do
OPMUL^code:=OPMUL^machine.genMod();
OPMUL^type:=new IntDTYPE();
end
}
OPMUL -> et #type ;
#type{
do
OPMUL^code:=OPMUL^machine.genEt();
OPMUL^type:=new BoolDTYPE();
end
}
-- unaire
FACTEUR ->  OPUN FACTEUR #type;
#type{
local
    t : DTYPE ;
do
    FACTEUR^code:= FACTEUR1^code + OPUN^code;
    t := FACTEUR1^type ;
     if ~(t.compareTo(OPUN^type)) then
        error(type_incompatible, OPUN^type, t);
     end
       FACTEUR^type := OPUN^type;
        
                                                         --genreration de code 
end
}
OPUN -> plus #type;
#type{
do
OPUN^code:="";-- Le plus unaire ne fais rien OPUN^machine.genBplus();
OPUN^type:=new IntDTYPE();
end
}
OPUN -> moins #type ;
#type{
do
OPUN^code:=OPUN^machine.genOpp();
OPUN^type:=new IntDTYPE();
end
}
OPUN -> non #type;
#type{
do
OPUN^code:=OPUN^machine.genNon();
OPUN^type:=new BoolDTYPE();
end
}
-- expressions de base
FACTEUR -> entier #gen;
#gen {
do                                                         
    FACTEUR^type := new IntDTYPE();
 --   FACTEUR^est_adresse := false;
    FACTEUR^code := FACTEUR^machine.genCst(entier^txt);
end
}
-- booleens
FACTEUR -> vrai #gen;
#gen {
do
  FACTEUR^type := new BoolDTYPE();
--  FACTEUR^est_adresse := false;
   FACTEUR^code := FACTEUR^machine.genCst("1");
 end
}
FACTEUR -> faux #gen;
#gen {
do
  FACTEUR^type := new BoolDTYPE();
--  FACTEUR^est_adresse := false;
  FACTEUR^code := FACTEUR^machine.genCst("0");
end
}

-- null
FACTEUR -> null #gen;
#gen {
do
  FACTEUR^type := new DTYPE("null", 0);
--  FACTEUR^est_adresse := false;
  FACTEUR^code := FACTEUR^machine.genNull();    ---faire genNull!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
end
}

FACTEUR -> F #type;
#type{
do
FACTEUR^type:= F^type;   
FACTEUR^code:=F^code;                       --generation du code
end
}

-- expression parenthesee
F -> paro E parf #type ;
#type{
do
F^type:=E^type;   
F^code:=E^code;                        --generation du code            
end
}

-- new
F -> nouveau TYPE paro ARGS parf #htype FX #gen #type;
global
it:INFOCLASS;
#htype{
local
i: INFO;
i1:INFO;
t:TDM;
do
   FX^nom:="";
i:= F^tdsProg.chercherGlobalement(TYPE^type.getNom());
match i 
 with INFOCLASS then
    it:=i;
    t:=it.getConstructors();
    i1:=t.chercherGlobalement(TYPE^type.getNom(),ARGS^listArg);
     if (i1=nil) then
        error(constr_existe_pas,TYPE^type.getNom(),ARGS^listArg);
     else
     FX^htype:=TYPE^type;--it.getType();
     FX^infoclass := i;
     end
                                    --generation de code
  else 
     error(class_non_existe,TYPE^type);
end
end}
#gen{
do
   F^code := F^machine.genMalloc(it.getTaille()) + FX^code ;  --TYPE^type
end}
#type{
do
F^type:=FX^type;
end}

-- objet courant
F -> this #htype FX  #type #gen;
#htype{
do
FX^nom:="";
FX^htype:=F^infoclass.getType();
FX^hcode:=F^machine.genThis(F^infoclass);
end}
#type{
do
F^type:=FX^type;
end
}

#gen{
do
F^code:=FX^code;
end
}
-- objet parent
F -> super #htype FX #type;
#htype{
local
mere:INFOCLASS;
do
 if (F^infoclass.hadParent()) then
    mere:=F^infoclass.getParent();
    FX^nom:=mere.getName();
    FX^htype:=mere.getType();  -- va etre redefini dans la regle ou il ya les arguments
 else
    error(pas_de_parent,F^infoclass.getName());    
 end
end}
#type{
do
F^type:=FX^type;
end
}

-- acces variable, parametre, ou attribut de this
F -> ident #htype FX #type #gen;
global
i:INFO;
#htype{
local
t: TDS;
t1:TDS;
do
--recherche de ident dans la tds des parametres de la methode
t:=F^infoMethod.getListParam();
i:=t.chercherGlobalement(ident^txt);
--i:=F^tdsParamh.chercherGlobalement(ident^txt);
 if (i=nil) then
    --recherche de ident dans tds du bloc cad comme variable locale
    --on fait recherche globale 
    i:=F^tds.chercherGlobalement(ident^txt);
    if (i=nil)  then
        --recherche dans les attributs de la classe et de sa classe mere
        t1:=F^infoclass.getAttributes();
        i:=t1.chercherGlobalement(ident^txt);
        if (i=nil)  then
            -- si il trouve pas , on cherche dans les methodes 
            FX^nom:=ident^txt;
            FX^htype:=F^infoclass.getType(); 
        else
            FX^htype:=i.getType();
            FX^nom:="";
        end     
    else
    FX^htype:=i.getType();
    FX^nom:="";
    end
else
    FX^htype:=i.getType();
    FX^nom:="";
 end
end
   
}
#type{
do
F^type:=FX^type;
end
}
#gen{
do  
    if 
    
    
    match i 
    with INFOVAR
    F^code :=F^machine.genAdr(i.getDep(), i.getReg());
end}

FX -> #type;
#type{
local
 
do
FX^code:=FX^hcode;
if (FX^htype=nil) then 
    error(pas_trouve,FX^nom);
else

    FX^type:=FX^htype; 
    end      
end}


FX -> pt ident #htype FX #type;
#type{
do
FX^type:=FX1^type;
end}
#htype{
local 
t1:TDS;
ia : INFO;
ic1:INFO;
ic2: INFOCLASS;
typ :DTYPE;
do
typ:=FX^htype;
ic1:=FX^tdsProg.chercherGlobalement(typ.getNom());
match ic1
 with INFOCLASS then
 ic2:=ic1;
 t1:=ic2.getAttributes();
--recherche dans les attributs de la classe et de sa classe mere
ia:=t1.chercherGlobalement(ident^txt);
    if ia=nil then
        FX1^nom:=ident^txt; --nom est herite
        FX1^htype:=FX^htype;
    else
        FX1^nom:="";
        FX1^htype:=ia.getType();
     end
end  
end                                               --generation de code
}



-- appel methode sur objet
FX -> paro ARGS parf #htype FX #type;
#type{
do
    FX^type:=FX1^type;
end}

#htype{
local
im:  INFOMETHOD;
ic: INFOMETHOD;
i:INFO;
--t1: TDS;
t2: TDM;
t3: TDM;
typ:DTYPE;
ic1:INFO;
ic2:INFOCLASS;
do
if (FX^nom.equals("")) then
    error(this_error);
end
typ:=FX^htype;
ic1:=FX^tdsProg.chercherGlobalement(typ.getNom());
match ic1
 with INFOCLASS then
 ic2:=ic1;
t2:=ic2.getMethods();
t3:=ic2.getConstructors();
--recherche dans la tds des methodes
 im:=t2.chercherGlobalement(FX^nom,ARGS^listArg);
    if im=nil then
        --recherche dans la tds des constructeurs  
       ic:=t3.chercherGlobalement(FX^nom,ARGS^listArg); 
       if ic=nil then
           error(methode_non_existante,FX^nom,ARGS^listArg,ic1.getName());
       else
           FX1^htype:=ic.getType();--pour une methode c est le type de retour
           end
    else
    FX1^htype:=im.getType();
        --    error(methode_sans_type,im.getName(),im.getType());

    end
end
end
}
-- liste d'arguments d'appel de methode
ARGS ->  E ARGSX #listArg ;
#listArg{
do
call ARGSX^listArg.inserer(E^type);
ARGS^listArg := ARGSX^listArg;
end}
ARGS -> #listArg; --cas d une methode sans parametres
#listArg{
do
ARGS^listArg :=new LTYPES();--nil;-- 
end}
ARGSX ->   virg E ARGSX #listArg ;
#listArg{
do
call ARGSX1^listArg.inserer(E^type);
ARGSX^listArg := ARGSX1^listArg;
end}

ARGSX -> #listArg;
#listArg{
do
ARGSX^listArg := new LTYPES();
end}


end

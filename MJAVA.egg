-- PROJET3 STL 12-13 - micro java : grammaire 
option auto= true;
option version = 0.0.1 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

--table des classes
inh tds :TDS for   
                 INSTS,INST,--BLOC, PARFS,PARFSX, PARF, 
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
           -- je crois qu'il faut enlever tout les trucs avec un X Ã  la fin 
  
 
 --table ou on met toutes les classes
 inh tdsProg: TDS for PROGRAMME, CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                 BLOC,SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
 --table des attributs          
--inh tda : TDS for DEFS, DEF ;
 --table des methodes
--inh tdm : TDS for DEFS, DEF, MCORPS, BLOC, INSTS, INST, SIX, E, ER, ES, F, 
  --                 AFFX, ERX, ESX, TX, ARGSX,ARGS;
 --table des constructeurs
--inh tdc : TDS for DEFS, DEF, MCORPS, BLOC, INSTS, INST, SIX, E, ER, ES, F, 
    --                AFFX, ERX, ESX, TX, ARGSX,ARGS;

--table de parametres
syn param: String for PARF;
inh tdsParamh :TDS for BLOC,INSTS,INST, SIX,E, ER, ES, F, AFFX,FACTEUR,TERME, ERX, ESX, TX, ARGSX,ARGS,FX;
syn tdsParam: TDS for PARFS,PARFSX;

syn superclass : INFOCLASS for SUPER;
syn type : DTYPE for TYPE, PARF, FACTEUR, E, ER,ES,AFFX,TERME,F,FX, ERX, ESX, TX,
OPREL,OPADD,OPMUL,OPUN ;
--type de retour de la mÃ©thode
inh typeR : DTYPE for BLOC, INSTS,INST,SIX;
--signature d une fonction
syn signature : LTYPES for PARFS, PARFSX;
 
syn listArg : LTYPES for ARGSX,ARGS;

--les infos sur de la classe a donner au corps de la classe
inh infoclass : INFOCLASS for CORPS, DEFS,DEF,INSTS,INST,BLOC,TYPE,
                 PARFS,PARFSX, PARF, 
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;
                               
--les infos sur de la methode a donner au corps de la classe
inh infoMethod : INFOMETHOD for INSTS,INST,BLOC,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX;               
inh nom :String for FX;
inh htype: DTYPE for FX;


--code
syn code : STRING for  CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                 BLOC, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX, OPADD,OPMUL,OPREL,OPUN;
   --main est le code a afficher
syn main : STRING for  CLASSES, DEFCLASSE, CORPS, DEFS, DEF;
--inh hcode : STRING for FX;-- CLASSES, DEFCLASSE, CORPS, DEFS, DEF,
                -- BLOC,SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                -- SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 --F,FX, ARGS, ARGSX;

--TAM
--inh tam : TAM for BLOC, INSTS,  INST, TERME, FACTEUR, FX, TERMES;
inh machine : AbstractMachine for PROGRAMME, CLASSES, DEFCLASSE, CORPS, DEFS, DEF,BLOC,
                 SUPER, TYPE, PARFS,PARFSX, PARF, INSTS,INST,
                 SIX, E, AFFX, ER,ES, ERX, ESX, TERME, FACTEUR, TX,
                 F,FX, ARGS, ARGSX, OPADD,OPMUL,OPREL,OPUN;

-- adresses
syn dep : INTEGER for BLOC, INST, INSTS, DEF;--, DEFS, ,DEFCLASSE,E;
inh hdep : INTEGER for BLOC,INST,INSTS,PARF, PARFS,PARFSX, DEFS, DEF, SIX, ARGSX ;
inh hdepParam :INTEGER for PARFS, PARF,PARFSX;
--inh hdep: INTEGER for DEFS, DEF, CORPS,CLASSES, DEFCLASSE, BLOC, INST, INSTS, SIX;
inh est_gauche: BOOLEAN for E,ER,ERX, TERME, ES, ESX, FACTEUR, TX, F, FX;

--dit si une expression est une adresse cad pointe sur une zone memoire
syn est_adresse: BOOLEAN for ER, ERX, ES,ESX, TERME, TX, FACTEUR, F, E ,AFFX;

-- les terminaux 
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ","; 
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar extend is  "extends";
sugar retour is  "return";
sugar this is  "this";
sugar super is  "super";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init #tds CLASSES #gen;
global
   machine : AbstractMachine;
   t: TDS;

#init {
local
do
   machine := PROGRAMME^source.getMachine();
   CLASSES^machine:=machine;
end
}

#tds{
do
-- creer la table pour les classes du programme
 t:= new TDS();
-- transmettre la table a  CLASSES
CLASSES^tdsProg:=t;
end
}
#gen {
local
  cp : STRING ; -- code de la procedure
do
 cp:=CLASSES^main+ CLASSES^code ;
 call machine.writeCode(PROGRAMME^source.getFileName(),cp); 
   -- code de la procedure : generer le prologue et l'epilogue 
   -- etiquette + taille des parametres + taille retour + code des instructions
 --  cp := tam.genFonction( ,0 , 0, BLOC^code);              --MOUNA
   -- generer le code complet
      -- ajouter un appel a la methode main en debut de programme
  call machine.genAsm( cp, "programme");
 
end
}

CLASSES -> #gen;
#gen{
do
CLASSES^main:="";
CLASSES^code:="";

end
}
CLASSES -> DEFCLASSE #dep  CLASSES #gen ;
#dep{
do
--CLASSES1^hdep := DEFCLASSE^dep ;
end
}
#gen{
do
CLASSES^main := DEFCLASSE^main + CLASSES1^main ;
CLASSES^code := DEFCLASSE^code + CLASSES1^code ;
end
}
-- definition d'une classe
DEFCLASSE -> classe ident SUPER #tds #gen1 CORPS #gen;
global
    ic : INFOCLASS ;
#tds{
local
    i:INFO;
do
   
 --  t :=  new TDS(DEFCLASSE^tdsProg);
 --  CORPS^tds := t;  -- on devrait pas rajouter la tds des classes meres ?
--   CORPS^classname:=ident^txt;   
    i := DEFCLASSE^tdsProg.chercherGlobalement(ident^txt);
    if i /= nil then
       
       error(class_existe_deja, ident^txt);
    else    
      -- creer une classe
      if(SUPER^superclass=nil) then
           ic := new INFOCLASS(ident^txt);
      else
           ic := new INFOCLASS(ident^txt, SUPER^superclass);   --il faut donner la liste des attributs et des methodes et sa classe mere
      end                               -- qui seront probablemnt des attribut synthetise
     call DEFCLASSE^tdsProg.inserer(ident^txt,  ic);
--     call ic.setParent(SUPER^superclass);
     CORPS^infoclass:=ic;

    end
end
}
#gen {   --generation de code !
do
--DEFCLASSE^dep := DEFCLASSE^hdep + 1;
DEFCLASSE^code := DEFCLASSE^machine.genConsDef(ident^txt,ic.getTaille())+ CORPS^code + ic.genereTVM();
DEFCLASSE^main := CORPS^main;
end
}

#gen1{
do
--CORPS^hdep := DEFCLASSE^hdep;
end 
}


SUPER -> #classmere;
#classmere{
do
SUPER^superclass:=nil;
end
}
SUPER -> extend ident #gen;

#gen {
local
    i : INFO ;
    ic: INFOCLASS;
do
    i := SUPER^tdsProg.chercherGlobalement(ident^txt);
    if i = nil then
       error(class_non_existe, ident^txt);
    else   
      match i 
      with INFOCLASS then
        ic:=i; 
      -- donner le nom de la classe mere a  la classe fille
        SUPER^superclass:=ic;  
      else
        error(pas_une_classe,ident^txt );
      end             
    end
end
}
CORPS -> aco #hdep DEFS acf #gen;
#hdep{
do
DEFS^hdep:=0;
end
}
#gen{
do
CORPS^main:=DEFS^main;
CORPS^code:=DEFS^code;
end
}

-- les attributs
DEFS -> #gen;
#gen{
do
DEFS^main:="";
DEFS^code:="";
end
}

DEFS ->  DEF #dep DEFS #gen;
#dep{
do
--    DEFS1^hdep := DEFS^hdep + DEF^dep ;
end
}
#gen{
do
DEFS^main:= DEF^main + DEFS1^main;
DEFS^code:= DEF^code + DEFS1^code;
end
}


-- attribut
DEF ->  TYPE ident pv #tds;
#tds {
local 
i : INFO;  
ia: INFOATTRIBUTE;
t:TDS;
do
                           -- pas de code pour les attributs
t:=DEF^infoclass.getAttributes();
i := t.chercherLocalement(ident^txt);   -- possiblite de redefinition dun attribut dans la classe
                                        -- fille                                          
    if i /= nil then
       error(attribut_existe_deja, ident^txt);
    else    
      -- creer un attribut
     ia := new INFOATTRIBUTE(ident^txt,TYPE^type,DEF^hdep,"HB");
       DEF^dep := DEF^hdep + TYPE^type.getTaille();
       if DEF^machine=nil then
       else
       DEF^code:="";--DEF^machine.genDecl(ident^txt, ia);          
       end

     --mise a jour de la tds des attributs
     call DEF^infoclass.addAttribute(ident^txt,ia);
     DEF^main:="";
     end
end
}

-- methode (fonction) 
DEF ->  TYPE ident paro #hdepParam PARFS parf #tds  BLOC #gen  ;
global
ic:INFOCLASS;
#hdepParam{
do
ic:= DEF^infoclass;--on stocke le this dans -1[LB] on augmente le deplacement pour les parametres de la taille de this
PARFS^hdepParam:=1+ic.getTaille();
end}
#tds {
local 
i : INFO;
im: INFOMETHOD;
im1: INFOMETHOD;
t:TDM;
s: String;
num:Integer;
do
 BLOC^hdep:=3;
 t:=DEF^infoclass.getMethods();
 i := t.chercherLocalement(ident^txt,PARFS^signature);
 if i /= nil then
    error(methode_existe_deja, ident^txt);
 else    
     -- creer une methode           
    im := new INFOMETHOD(ident^txt,TYPE^type,PARFS^signature,true);  
    --ajouter la liste des parametres(une TDS) a l infoMethod 
    call im.setListParam(PARFS^tdsParam);
  --  call DEF^tds.inserer(ident^txt,im);
     --mise a jour de la tds des methodes
    s:=im.getName();
    i:=t.chercherGlobalement(ident^txt,PARFS^signature);
    if i/= nil then
        match i with INFOMETHOD then
        im1:=i;
        num:=im1.getNumE();
        call im.setNumEtiq(num);
        call DEF^infoclass.addMethod(s,im, num);
        end  
     else
        call DEF^infoclass.addMethod(s,im);  
    end

     
    --on donne l infoMethod au bloc 
    BLOC^infoMethod:=im;
    BLOC^tdsParamh:=PARFS^tdsParam;
    BLOC^typeR:=TYPE^type;
    
    end
end
}
#gen{
local
tailleParam:Integer;
do
DEF^dep:=0; --pas de deplacement pour une methode
 if PARFS^signature/=nil then
    tailleParam:=PARFS^signature.getTaille();
 else
    tailleParam:=0;
 end
 DEF^code:= DEF^machine.genFonction(ic.getName(),ident^txt,PARFS^signature,tailleParam, TYPE^type.getTaille() ,ic.getTaille(), BLOC^code);   
 DEF^main:="";
 end
 }
-- methode (procedure)
DEF ->  void ident paro #hdepParam PARFS  parf  #tds BLOC #gen ;
global
ic:INFOCLASS;
#hdepParam{
do --on stocke le this dans -1[LB] on augmente le deplacement pour les parametres de la taille de this
ic:= DEF^infoclass;
PARFS^hdepParam:=1+ic.getTaille();
end}

#tds {
local 
i : INFO;
im:INFOMETHOD;
t:TDM;
s:String;
do
 BLOC^hdep:=3;
 t:=DEF^infoclass.getMethods();
 i := t.chercherLocalement(ident^txt,PARFS^signature);
 if i /= nil then
      error(methode_existe_deja, ident^txt);
    else    
     im := new INFOMETHOD(ident^txt,new VoidDTYPE() ,PARFS^signature,false);
     --ajouter la liste des parametres(une TDS) a l infoMethod 
    call im.setListParam(PARFS^tdsParam);  
--    call DEF^tds.inserer(ident^txt,im);
    s:=im.getName();
    call DEF^infoclass.addMethod(s,im);
     
    --on donne l infoMethod au bloc
    BLOC^infoMethod:=im;         --on peut enlever les deux lignes suivantes
    BLOC^tdsParamh:=PARFS^tdsParam;
    BLOC^typeR:=im.getType();
    end
end
}

#gen{
local
tailleParam:Integer;
do
DEF^dep:=0; --pas de deplacement pour une methode
 
if PARFS^signature/=nil then
    tailleParam:=PARFS^signature.getTaille();
 else
    tailleParam:=0;
 end
 
 if ident^txt.equals("main") then
    DEF^main:= DEF^machine.genFonction(ic.getName(),ident^txt,PARFS^signature,tailleParam,0,ic.getTaille() , BLOC^code); 
    DEF^code:= "";
 else
  DEF^code:= DEF^machine.genFonction(ic.getName(),ident^txt,PARFS^signature,tailleParam,0,ic.getTaille() , BLOC^code);  
    DEF^main:="";
  end
 end
 }

-- constructeur
DEF -> ident  paro #hdepParam PARFS parf #tds BLOC #gen;
global
im:INFOMETHOD;
ic:INFOCLASS;
#hdepParam{
do
ic:= DEF^infoclass;
PARFS^hdepParam:=0;
end}
#tds{
local
i:INFO;
nomClass:String;
t:TDM;
a:String;
ti:DTYPE;
s:String;
do 
 BLOC^hdep:=3;
 nomClass:=DEF^infoclass.getName();
 if (ident^txt.equals( nomClass)) then
  t:= DEF^infoclass.getConstructors();

  i:= t.chercherLocalement(ident^txt,PARFS^signature);
  if (i=nil) then 
    i:= t.chercherGlobalement(ident^txt,PARFS^signature);
    if (i/=nil) then
        --traitement de super
    end
    im := new INFOMETHOD(ident^txt,new ClassDTYPE(ident^txt) ,PARFS^signature,false);
        --ajouter la liste des parametres(une TDS) a l infoMethod 
    call im.setListParam(PARFS^tdsParam);               
--    call DEF^tds.inserer(ident^txt,im);
    s:=im.getName();
    call DEF^infoclass.addConstructor(s,im);
    
    --on donne l infoMethod au bloc
    BLOC^infoMethod:=im; 
    BLOC^tdsParamh:=PARFS^tdsParam;
    BLOC^typeR:=im.getType();
  else
      error(construc_existe_deja, ident^txt);  
  end                                          
 else
      error(construc_name, ident^txt);  
 end
end
 }
#gen{
local
tailleParam:Integer;
t:DTYPE;
do
DEF^dep:=0; --pas de deplacement pour une methode
t:=im.getType();
if PARFS^signature/=nil then
    tailleParam:=PARFS^signature.getTaille();
 else
    tailleParam:=0;
 end
 --generation du code pour le constructeur, au debut genMalloc qui met l'adresse de this en 3[LB]
 DEF^code:= DEF^machine.genCons(ic.getName(),PARFS^signature,tailleParam, t.getTaille() , BLOC^code);   
  DEF^main:="";
 end
 }
-- les types

TYPE-> int #type;
#type{
do 
    TYPE^type := new IntDTYPE(); 
end
}

TYPE-> bool #type;
#type{
do 
    TYPE^type := new BoolDTYPE();  
end
}

TYPE-> ident #type;   --les classes
#type{

local
   i : INFO ;
   it : INFOCLASS;
do
    -- rechercher l'ident dans la tds du programme  
    i := TYPE^tdsProg.chercherGlobalement(ident^txt);  
    if i = nil then
      error(ident_non_existant, ident^txt);
    else
       match i
       with INFOCLASS then     
         it := i ;
         TYPE^type :=  it.getType();
       else
          error(ident_non_existant, ident^txt);
       end
    end
end
}



-- parametres de methodes
PARFS -> #paramlist;   -- methode sans parametre on cree une liste qui reste vide
#paramlist{
do 
PARFS^signature:=nil;--new LTYPES();
PARFS^tdsParam:= new TDS();
end
}

PARFS -> PARF #hdepParam PARFSX #params;
global
i: INFOVAR;
#hdepParam{
do
 i:= new INFOVAR(PARF^type,0-PARFS^hdepParam,"LB");          
 PARFSX^hdepParam:= PARFS^hdepParam + PARF^type.getTaille() ;    --mise a jour de hdepParam
 end
 }

#params{
do
call PARFSX^signature.inserer(PARF^type); 
PARFS^signature := PARFSX^signature;     
call PARFSX^tdsParam.inserer(PARF^param,i);                                          
PARFS^tdsParam:=PARFSX^tdsParam;
end
}
PARFSX -> #params;
#params{
do
PARFSX^tdsParam:=new TDS();
PARFSX^signature := new LTYPES(); 
end
}

PARFSX -> virg PARF #hdepParam PARFSX #params;
global
i: INFOVAR;
#hdepParam{
do
 i:= new INFOVAR(PARF^type,0-PARFSX^hdepParam,"LB");             
 PARFSX1^hdepParam:= PARFSX^hdepParam + PARF^type.getTaille() ;    --mise a jour de hdepParam
 end
 }
#params{
do
call PARFSX1^signature.inserer(PARF^type);      -- methode add de arrayList attention a l'ordre
                                                -- add ajoute en fin de liste donc j ai change en add(0,elt) pour ajouter en tete
 call PARFSX1^tdsParam.inserer(PARF^param,i); 
PARFSX^signature :=PARFSX1^signature;
PARFSX^tdsParam:=PARFSX1^tdsParam;

end
}
PARF -> TYPE ident #param;
#param{
do
PARF^type := TYPE^type;   
PARF^param:= ident^txt;                             
end                                                    
}

-- corps de methode et bloc d'instructions
BLOC -> aco #tds INSTS acf #gen;

#tds{
do
INSTS^tds:= new TDS();  

                            --TAM
end
}
#gen {
local
t:TDS;
do
--   t:=INSTS^tds;
--   write "; tds:\n" + t;
--   write "; taille des locales = " + (INSTS^adr - BLOC^hadr)+ "\n";         --copiee du BLOC
    BLOC^dep:=INSTS^dep;
   BLOC^code := INSTS^code;-- + BLOC^machine.genFree(INSTS^dep - BLOC^hdep);
end
}

-- instructions
INSTS -> #gen;
#gen{
do
-- une fonction doit avoir une instruction de retour
if (INSTS^infoMethod.isFunction()) then
    if ~(INSTS^infoMethod.getReturnInst()) then
    error(func_retour);
    end
end
    INSTS^dep := INSTS^hdep;
    INSTS^code := "";
end
}

INSTS -> INST #adr INSTS #gen;

#adr {
do
--    write "@ courante = " + INST^dep + "\n";
    INSTS1^hdep := INST^dep;
end
}


#gen {
do
   INSTS^dep := INSTS1^dep;
 INSTS^code := INST^code + INSTS1^code;
end
}



-- declaration de variable locale sans init
INST-> TYPE ident pv #type #gen ;
global 
    i : INFO ;
    iv : INFOVAR ;

#type{ 
local
    t: TDS;
    t2:TDS;
do
    t:=INST^infoMethod.getListParam();
    --recherche dans la tds ou il y a les parametres de la methodes
   -- i:=INST^tdsParamh.chercherGlobalement(ident^txt);                                                     -- truc a enlever tdsParamh
    i:= t.chercherGlobalement(ident^txt);
    if i/=nil then
      error(var_egal_param,ident^txt);
    else
        i := INST^tds.chercherLocalement(ident^txt);
        if i /= nil then
          error(var_existe_deja, ident^txt);
        else
        -- creer une variable
        iv := new INFOVAR(TYPE^type, INST^hdep, "LB");    
             INST^dep := INST^hdep + TYPE^type.getTaille();                  

        --ajouter dans la tds du bloc
        call INST^tds.inserer(ident^txt,  iv);
        
        --ajouter la variable a la tds des variables de infoMethod
        t2:=INST^infoMethod.getListVar();
        call t2.inserer(ident^txt,  iv);        
        end
     end
end

}  

#gen{
do
     INST^code := INST^machine.genDecl(ident^txt, iv);
 end 
     }

--declaration avec affectation
INST-> TYPE ident affect #est_gauche E pv #type #gen;
global 
    i : INFO ;
    iv : INFOVAR ;
#est_gauche{
do
E^est_gauche:=false;
end
}
#type {
local
    t: TDS;
    t2:TDS;
do
    t:=INST^infoMethod.getListParam();
    --recherche dans la tds ou il y a les parametres de la methodes
   -- i:=INST^tdsParamh.chercherGlobalement(ident^txt);                                                     -- truc a enlever tdsParamh
    i:= t.chercherGlobalement(ident^txt);
    if i/=nil then
      error(var_egal_param,ident^txt);
    else
        i := INST^tds.chercherLocalement(ident^txt);
        if i /= nil then
            error(var_existe_deja, ident^txt);
        elseif ~E^type.compareTo(TYPE^type) then
            error(type_incompatible, TYPE^type, E^type);
        else
            -- creer une variable
        iv := new INFOVAR(TYPE^type, INST^hdep, "LB");  
        INST^dep := INST^hdep + TYPE^type.getTaille();       
        
        call INST^tds.inserer(ident^txt,  iv); 
        
        --ajouter la variable a la tds des variables de infoMethod
        t2:=INST^infoMethod.getListVar();
        call t2.inserer(ident^txt,  iv);
                
        end
     end
end
}

#gen{
do
     INST^code := INST^machine.genDecl(ident^txt, iv,E^code) ;
 end 
     }

-- instruction expression
INST -> #est_gauche E pv #gen;
#est_gauche{
do
E^est_gauche:=true;
end
}
#gen{
do
INST^dep:=0;    ------------------------------------------------------------------------------------------------------ a voir
INST^code:=E^code;
end
}                                  --generation du code ,TAM
-- bloc d'instructions
INST -> BLOC #gen ;                                  --generation du code ,TAM
#gen{
do
INST^dep:=BLOC^dep;
INST^code:=BLOC^code;
end
} 

-- conditionnelle
INST -> si paro #est_gauche E parf #type  BLOC SIX #gen ;
#est_gauche{
do
E^est_gauche:=false;
end
}
#gen {
do
    INST^dep:= INST^hdep;
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code) ;  
end
}

#type {
do
   if ~E^type.compareTo(new BoolDTYPE()) then
      error(type_incompatible, E^type); 
   end
end
}
SIX -> sinon BLOC #gen ;
#gen{
do
SIX^code := BLOC^code;
end
}

SIX ->  #gen;
#gen{
do
 SIX^code := "";                       
end
}
-- return
INST -> retour #est_gauche E pv #type #gen ;
#est_gauche{
do
E^est_gauche:=false;
end
}
#type{
local
i:INFOMETHOD;
b:boolean;
do
if (INST^infoMethod.isFunction()) then
 if  ~(INST^typeR.compareTo(E^type)) then
     error(type_incompatible,INST^typeR,E^type);
 else
     call INST^infoMethod.setReturnInst();
 end
else
    error(pas_de_retour);
                                                            -- tam
end
end 
}
#gen{
do
INST^code:= E^code;--INST^machine.genRet(E^type.getTaille(),"LB");
INST^dep:=0;                                                                                            --------------------------------------------A voir
end
}


-- les expressions
E -> #gen ER AFFX #type #est_adresse;
#est_adresse{
do
if AFFX^est_adresse then          
   E^est_adresse:=ER^est_adresse;
else  -- cad il y a une affectaion donc E ne peut etre une adresse 
   E^est_adresse:=false;
end  
end}
#gen{
do
ER^est_gauche:=E^est_gauche;
end}

#type{
local
    t : DTYPE ;
do
    E^type := ER^type;
    t := AFFX^type ;
    if  t/= nil then
     if ~(t.compareTo(ER^type)) then
        error(type_incompatible, AFFX^type, ER^type);
     end
    end
if ~E^est_gauche then --E sera affectee a quelque chose
    E^code:= ER^code ;
else    
    
 if ER^est_adresse then         --ER est une adresse (cad pointeur) dans on ecrit a cette adresse 
    if AFFX^type=nil then
    E^code:= ER^code + E^machine.genWriteMem(0);-- AFFX^code +
    else
    E^code:= AFFX^code + ER^code + E^machine.genWriteMem(AFFX^type.getTaille());
    end 
 else                           -- ER est une variable locale 
    E^code:= AFFX^code + ER^code;
 end                                                     
end

end
}

-- affectation
AFFX ->  #gen affect ER #type ;
#gen{
do
ER^est_gauche:=false;
end}
#type{
do
AFFX^est_adresse:=false;
AFFX^type:=ER^type;
AFFX^code:=ER^code;
end}
AFFX -> #type ;

#type{
do
AFFX^est_adresse:=true;
AFFX^type:=nil;                       
AFFX^code:="";                                                        --generation de code 
end}


-- relation
ER ->   ES ERX #type #est_adresse;
#est_adresse{
do
if ERX^est_adresse then         -- cad il n'y a une operation de relation donc 
   ER^est_adresse:=ES^est_adresse;
else  -- cad il y a une operation de relation donc ER ne peut etre une adresse ca sera un boolean
     ER^est_adresse:=false;
end  
end}
#type{
local
    t : DTYPE ;
do
    ER^code:=ES^code+ ERX^code;
    t := ERX^type ;
    if  t/= nil then
     if ~(t.compareTo(ES^type)) then
        error(type_incompatible, ERX^type, ES^type);
     else
            ER^type := new BoolDTYPE();
     end
    else
      ER^type:=ES^type;
    end  
                                                         --generation de code 
end
}
ES ->  TERME ESX #type #est_adresse;
#est_adresse{
do
if ESX^est_adresse then         -- cad il y a une operation arithmetique  
   ES^est_adresse:=TERME^est_adresse;
else  -- cad il y a une operation arithmetique donc ER ne peut etre une adresse ca sera un boolean
     ES^est_adresse:=false;
end  
end}
#type{
local
    t : DTYPE ;
do
    ES^code:= TERME^code + ESX^code;
    t := ESX^type ;
    if  t/= nil then
     if ~(t.compareTo(TERME^type)) then
        error(type_incompatible, ESX^type, TERME^type);
     end
    end
   ES^type := TERME^type;
end
}
ERX ->  OPREL ES #type #est_adresse;
#est_adresse{
do
    ERX^est_adresse:=false;                                -- cad il y a une operation arithmetique   
end}
#type{
local
    t : DTYPE ;
do
    ERX^code:=ES^code+OPREL^code;
    t := ES^type ;
    if ~(OPREL^type=nil) then           --le type de OPREL= nil dans le cas de = et /= marche 
                                        -- pour tout les types
     if ~(t.compareTo(OPREL^type)) then
        error(type_incompatible, OPREL^type, ES^type);
     end
       ERX^type := ES^type;
     end
        
                                                         --generation de code 
end
}

ERX -> #type ;
#type{
do
ERX^code:="";
ERX^type:=nil;
ERX^est_adresse:=true;  
end}

OPREL -> inf #type ;
#type{
do
OPREL^code:=OPREL^machine.genInf();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> infeg #type ;
#type{
do
OPREL^code:=OPREL^machine.genInfEg();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> sup #type ;
#type{
do
OPREL^code:=OPREL^machine.genSup();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> supeg #type;
#type{
do
OPREL^code:=OPREL^machine.genSupEg();
OPREL^type:=new IntDTYPE();
end
}
OPREL -> eg  #type;
#type{
do
OPREL^code:=OPREL^machine.genEg();
OPREL^type:=nil;
end
}
OPREL -> neg #type;
#type{
do
OPREL^code:=OPREL^machine.genNon();
OPREL^type:=nil;
end
}
-- addition, ...
ESX ->   OPADD TERME ESX #type ;
#type{
local
    t1 : DTYPE ;
    t2 : DTYPE ;
do
    ESX^est_adresse:=false;  
    ESX^code:=TERME^code + ESX1^code + OPADD^code;
    t1 := TERME^type ;
    t2 := ESX1^type ; 
    if ~(t1.compareTo(OPADD^type)) then
        error(type_incompatible, OPADD^type, t1);
    else
        if (t2/=nil) then  
            if ~(t2.compareTo(t1))then 
                error(type_incompatible, t1, t2);  
            end
        end
          ESX^type := OPADD^type;
     end        
                                                     --generation de code 
end
} 

ESX -> #type;
#type{
do
ESX^est_adresse:=true;  
ESX^code:="";
ESX^type:=nil;
end}
OPADD -> plus #type;
#type{
do
OPADD^type:=new IntDTYPE();
OPADD^code:=OPADD^machine.genAddition();
end}
OPADD -> moins #type;
#type{
do
OPADD^code:=OPADD^machine.genSoustraction();
OPADD^type:=new IntDTYPE();
end}
OPADD -> ou #type ;
#type{
do
OPADD^code:=OPADD^machine.genOu();
OPADD^type:=new BoolDTYPE();
end}

TERME ->  FACTEUR TX #type #est_adresse;
#est_adresse{
do
if TX^est_adresse then         -- cad il y a une operation arithmetique  
   TERME^est_adresse:=FACTEUR^est_adresse;
else  -- cad il y a une operation arithmetique donc ER ne peut etre une adresse ca sera un boolean
    TERME^est_adresse:=false;
end  
end}

#type{
local
    t : DTYPE ;
do
    TERME^code:=FACTEUR^code + TX^code;
    t := TX^type ;
    if  t/= nil then
     if ~(t.compareTo(FACTEUR^type)) then
        error(type_incompatible, TX^type, FACTEUR^type);
     end
    end
     TERME^type :=FACTEUR^type;

                                                         --generation de code 
end
}
-- multiplication, ...
TX ->   OPMUL FACTEUR TX #type ;
#type{
local
    t1 : DTYPE ;
    t2 : DTYPE ;
do
    TX^est_adresse:=false;
    TX^code:= FACTEUR^code + TX1^code + OPMUL^code;
    t1 := FACTEUR^type ;
    t2 := TX1^type ;
    if ~(t1.compareTo(OPMUL^type)) then
        error(type_incompatible, OPMUL^type, t1);
    else
        if (t2/=nil) then  
            if ~(t2.compareTo(t1))then 
                error(type_incompatible, t1, t2);  
            end
        end
       TX^type := OPMUL^type;
     end        
                                                     --generation de code 
end
}
TX -> #type;
#type{
do
TX^code:="";
TX^type:=nil;
TX^est_adresse:=true;
end
}
OPMUL -> mult #type ;
#type{
do
OPMUL^code:=OPMUL^machine.genMult();
OPMUL^type:=new IntDTYPE();
end
}
OPMUL -> div #type ;
#type{
do
OPMUL^code:=OPMUL^machine.genDiv();
OPMUL^type:=new IntDTYPE();
end
}
OPMUL -> mod #type;
#type{
do
OPMUL^code:=OPMUL^machine.genMod();
OPMUL^type:=new IntDTYPE();
end
}
OPMUL -> et #type ;
#type{
do
OPMUL^code:=OPMUL^machine.genEt();
OPMUL^type:=new BoolDTYPE();
end
}
-- unaire
FACTEUR ->  OPUN FACTEUR #type;
#type{
local
    t : DTYPE ;
do
    FACTEUR^est_adresse:=false;
    FACTEUR^code:= FACTEUR1^code + OPUN^code;
    t := FACTEUR1^type ;
     if ~(t.compareTo(OPUN^type)) then
        error(type_incompatible, OPUN^type, t);
     end
       FACTEUR^type := OPUN^type;
        
                                                         --genreration de code 
end
}
OPUN -> plus #type;
#type{
do
OPUN^code:="";-- Le plus unaire ne fais rien OPUN^machine.genBplus();
OPUN^type:=new IntDTYPE();
end
}
OPUN -> moins #type ;
#type{
do
OPUN^code:=OPUN^machine.genOpp();
OPUN^type:=new IntDTYPE();
end
}
OPUN -> non #type;
#type{
do
OPUN^code:=OPUN^machine.genNon();
OPUN^type:=new BoolDTYPE();
end
}
-- expressions de base
FACTEUR -> entier #gen;
#gen {
do   
    FACTEUR^est_adresse:=false;                                                 
    FACTEUR^type := new IntDTYPE();
    FACTEUR^code := FACTEUR^machine.genCst(entier^txt);
end
}
-- booleens
FACTEUR -> vrai #gen;
#gen {
do
  FACTEUR^type := new BoolDTYPE();
  FACTEUR^est_adresse := false;
  FACTEUR^code := FACTEUR^machine.genCst("1");
 end
}
FACTEUR -> faux #gen;
#gen {
do
  FACTEUR^type := new BoolDTYPE();
  FACTEUR^est_adresse := false;
  FACTEUR^code := FACTEUR^machine.genCst("0");
end
}

-- null
FACTEUR -> null #gen;
#gen {
do
  FACTEUR^type := new DTYPE("null", 0);
  FACTEUR^est_adresse := false;
  FACTEUR^code := "";--FACTEUR^machine.genNull();    ---faire genNull!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
end
}

FACTEUR -> F #type;
#type{
do
FACTEUR^est_adresse:=F^est_adresse;
FACTEUR^type:= F^type;   
FACTEUR^code:=F^code;                       --generation du code
end
}

-- expression parenthesee
F -> paro E parf #type ;
#type{
do
F^est_adresse:=E^est_adresse;
F^type:=E^type;   
F^code:=E^code;                        --generation du code            
end
}

-- new
F -> nouveau TYPE paro ARGS parf #htype FX #gen #type;
global
it:INFOCLASS;
i1:INFO;
#htype{
local
i: INFO;
t:TDM;
do
   FX^nom:="";
i:= F^tdsProg.chercherGlobalement(TYPE^type.getNom());
match i 
 with INFOCLASS then
    it:=i;
    t:=it.getConstructors();
    i1:=t.chercherGlobalement(TYPE^type.getNom(),ARGS^listArg);
     if (i1=nil) then
        error(constr_existe_pas,TYPE^type.getNom(),ARGS^listArg);
     else
     FX^htype:=TYPE^type;--it.getType();
     FX^infoclass := i;
     end
                                    --generation de code
  else 
     error(class_non_existe,TYPE^type);
end
end}
#gen{
local
ia1:INFOMETHOD;
do
   match i1 with INFOMETHOD then 
   ia1:=i1;
   F^code :=F^machine.genCalli(ia1,FX^code);--+ F^machine.genMalloc(it.getTaille()) + FX^code ;  --TYPE^type       -- l'adresse du nouveau objet crée est dans la pile suivi du code de FX(store/load)
   end                                                     -- on dit a FX qu'il doit faire un laod
end}
#type{
do
F^est_adresse:=true;
F^type:=FX^type;
end}

-- objet courant
F -> this #htype FX  #type #gen;
#htype{
do
FX^nom:="";
FX^htype:=F^infoclass.getType();
--FX^hcode:=F^machine.genThis(F^infoclass);
end}
#type{
do
F^type:=FX^type;
end
}

#gen{
do
F^est_adresse:=true;

 if F^infoMethod.isConstructor() then        --on est dans un constructeur le this est stocké en 3[LB]
        F^code:=F^machine.genAdr(3,"LB")+F^machine.genReadMem(1)+FX^code;   --on LOADA 3[LB] puis on LOADI(1) =>@ de this
 else                                       -- on est pas dans un constructeur this est stocké en -1[LB]
        F^code:=F^machine.genAdr(0-1,"LB")+F^machine.genReadMem(1)+FX^code; 
 end
end
}
-- objet parent
F -> super #htype FX #type;
#htype{
local
mere:INFOCLASS;
do
 if (F^infoclass.hadParent()) then
    mere:=F^infoclass.getParent();
    FX^nom:=mere.getName();
    FX^htype:=mere.getType();  -- va etre redefini dans la regle ou il ya les arguments
 else
    error(pas_de_parent,F^infoclass.getName());    
 end
end}
#type{
do
F^est_adresse:=false;
F^type:=FX^type;
F^code:="";--F^machine.genCall(F^infoclass
end
}

-- acces variable, parametre, ou attribut de this
F -> ident #htype FX #type #gen;
global
i:INFO;
#htype{
local
typ:DTYPE;
t: TDS;
t1:TDS;
do
--recherche de ident dans la tds des parametres de la methode
t:=F^infoMethod.getListParam();
i:=t.chercherGlobalement(ident^txt);
--i:=F^tdsParamh.chercherGlobalement(ident^txt);
 if (i=nil) then
    --recherche de ident dans tds du bloc cad comme variable locale
    i:=F^tds.chercherGlobalement(ident^txt);
    if (i=nil)  then
        --recherche dans les attributs de la classe et de sa classe mere
        t1:=F^infoclass.getAttributes();
        i:=t1.chercherGlobalement(ident^txt);        
        if (i=nil)  then
            -- si il trouve pas , on cherche dans les methodes 
            FX^nom:=ident^txt;
            FX^htype:=F^infoclass.getType(); 
  --          FX^hest_adresse:=false;
        
        --ident est un attribut
        else
  --          FX^hest_adresse:=true;
            FX^htype:=i.getType();
            FX^nom:="";
        end     
    
    
    -- ident est une variable
    else
    FX^htype:=i.getType();
    FX^nom:="";

    end

--ident est un parametre
else
--    FX^hest_adresse:=false;
    FX^htype:=i.getType();
    FX^nom:="";
 end
end
   
}
#type{
do
F^type:=FX^type;
end
}
#gen{
local
iv:INFOVAR;
ia:INFOATTRIBUTE;
t:DTYPE;
do  

t:=i.getType();
  match i 
  with INFOVAR then             --parametre ou variable
  iv:=i;
	if t.compareTo(new IntDTYPE())| t.compareTo(new BoolDTYPE()) then
	    F^est_adresse:=false;
	    if (F^est_gauche) then
	       F^code:=F^machine.genAdr(iv.getDep(), iv.getReg());--empiler l'adresse de la variable
	    else
	       F^code:=F^machine.genMem(iv.getDep(), iv.getReg(), t.getTaille());      --empiler la valeur de la variable
	    end
	 else
        F^est_adresse:=true;
	    F^code:= F^machine.genAdr(iv.getDep(), iv.getReg()) +F^machine.genReadMem(1)  +FX^code;    --empiler l'adresse de la variable
	end
   with INFOATTRIBUTE then       --attribut
   ia:=i;
        F^est_adresse:=true;
        F^code:=F^machine.genAdrField(ia.getDep()) + FX^code;     --empiler l'adresse de l'attribut
   else                          --methode
        F^est_adresse:=true;
        F^code:=FX^code; 
  end
end}

FX -> #type;
#type{
local
 
do
--FX^est_adresse:=false;
if (FX^htype=nil) then 
    error(pas_trouve,FX^nom);
else

    FX^type:=FX^htype; 
    FX^code:="";
--    if FX^est_gauche then
--        FX^code:=FX^machine.genComment("adresse");
--    else
--        if FX^hest_adresse then
--            FX^code:=FX^machine.genComment("valeur")+ FX^machine.genReadMem(FX^htype.getTaille()) ;  
--        else 
--            FX^code:=FX^machine.genComment("variable")+ FX^machine.genMem(FX,,FX^htype.getTaille()) ;         
--end 
    
    end      
end}


FX -> pt ident #htype FX #type #gen;
global 
ia: INFO;
typ :DTYPE;
#type{
do
FX^type:=FX1^type;
end}
#htype{
local 
t1:TDS;
ic1:INFO;
ic2: INFOCLASS;
do
typ:=FX^htype;
ic1:=FX^tdsProg.chercherGlobalement(typ.getNom());
match ic1
 with INFOCLASS then
 ic2:=ic1;
 t1:=ic2.getAttributes();
--recherche dans les attributs de la classe et de sa classe mere
ia:=t1.chercherGlobalement(ident^txt);
    if ia=nil then
        FX1^nom:=ident^txt; --nom est herite
        FX1^htype:=FX^htype;
    else
            -------------------------------------------------------------------------------------------------Nom dattribut et de methode pareil
        FX1^nom:="";
        FX1^htype:=ia.getType();
     end
end  
end                                               --generation de code
}

#gen{
local
infoa:INFOATTRIBUTE;
do 
--FX^est_adresse:=true;
   if ia /=nil then
   match ia 
   with INFOATTRIBUTE then
   infoa:=ia;
      FX^code:= FX^machine.genAdrField(infoa.getDep()) + FX1^code;
   end
   else 
      FX^code:=FX1^code;
  
end
end}


-- appel methode sur objet
FX -> paro ARGS parf #htype FX #type;
global
i:INFOMETHOD;
#htype{
local
im:  INFOMETHOD;
ic: INFOMETHOD;
t2: TDM;
t3: TDM;
typ:DTYPE;
ic1:INFO;
ic2:INFOCLASS;
do
if (FX^nom.equals("")) then
    error(this_error);
end
typ:=FX^htype;
ic1:=FX^tdsProg.chercherGlobalement(typ.getNom());
match ic1
 with INFOCLASS then
 ic2:=ic1;
t2:=ic2.getMethods();
t3:=ic2.getConstructors();
--recherche dans la tds des methodes
 im:=t2.chercherGlobalement(FX^nom,ARGS^listArg);
    if im=nil then
        --recherche dans la tds des constructeurs  
       ic:=t3.chercherGlobalement(FX^nom,ARGS^listArg); 
       if ic=nil then
           error(methode_non_existante,FX^nom,ARGS^listArg,ic1.getName());
       else
           FX1^htype:=ic.getType();--pour une methode c est le type de retour
           i:=ic;
           
       end
    else
    FX1^htype:=im.getType();
    i:=im;
    end
end
end
}
#type{
do
 --   FX^est_adresse:=true;
    FX^type:=FX1^type;
    FX^code:=FX^machine.genCalli(i, FX1^code);
--    FX^code := FX^machine.genAdr(0, "ST") + FX^machine.genCall(etiq,ARGS^code ) + FX1^code;
end}
-- liste d'arguments d'appel de methode
ARGS -> #est_gauche E #hdep ARGSX #listArg ;
global
d:Integer;
#est_gauche{
do
E^est_gauche:=false;
end
}
#hdep{
do
 --  creer le parametre
 -- creer une variable pour le parametre (dep =  - taille par)
  d:= E^type.getTaille();
ARGSX^hdep:=-2 -d;
end}
#listArg{
local 
do
--ARGS^hdep:=-2;
call ARGSX^listArg.inserer(E^type);
ARGS^listArg := ARGSX^listArg;

  ARGS^code:=E^code +ARGS^machine.genAdr(-2, "LB") +ARGSX^code;
  
end}
ARGS -> #listArg; --cas d une methode sans parametres    -------------------------------------------------------------------------------------------------Nom dattribut et de methode pareil
#listArg{
do
ARGS^code:="";
ARGS^listArg :=new LTYPES();--nil;-- 
end}
ARGSX ->   virg #est_gauche E #hdep ARGSX #listArg ;
global
d:Integer;
#est_gauche{
do
E^est_gauche:=false;
end
}
#hdep{
do
 --  creer le parametre
 -- creer une variable pour le parametre (dep =  - taille par)
  d:= E^type.getTaille();
ARGSX1^hdep:=ARGSX^hdep -d;
end}
#listArg{
do
call ARGSX1^listArg.inserer(E^type);
ARGSX^listArg := ARGSX1^listArg;
ARGSX^code:=E^code +ARGSX^machine.genAdr(ARGSX^hdep, "LB") +ARGSX1^code;
end}

ARGSX -> #listArg;
#listArg{
do
ARGSX^listArg := new LTYPES();
ARGSX^code:="";
end}


end
